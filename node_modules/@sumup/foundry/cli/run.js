"use strict";
/**
 * Copyright 2019, SumUp Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const util_1 = require("util");
const fp_1 = require("lodash/fp");
const spawn_1 = require("../lib/spawn");
const logger = __importStar(require("../lib/logger"));
const readFileAsync = util_1.promisify(fs_1.readFile);
const accessAsync = util_1.promisify(fs_1.access);
function shouldStopRecursion(path) {
    return !/^.+node_modules/.test(path);
}
async function resolveTo(path, name) {
    if (shouldStopRecursion(path)) {
        return '';
    }
    const packageJsonPath = path_1.join(path, name);
    try {
        await accessAsync(packageJsonPath);
        return packageJsonPath;
    }
    catch (err) {
        const parentPath = path_1.resolve(path, '..');
        return resolveTo(parentPath, name);
    }
}
async function getPackageJsonPath(name, useRelative = false) {
    const pathMain = require.resolve(name);
    const pathPackage = await resolveTo(pathMain, 'package.json');
    return useRelative ? path_1.relative(__dirname, pathPackage) : pathPackage;
}
function isRelativePath(path) {
    const firstChar = path.split('')[0];
    return firstChar === '.';
}
async function loadJson(path) {
    const isRelative = isRelativePath(path);
    if (isRelative) {
        throw new TypeError(`Relative paths are not supported: ${path}`);
    }
    try {
        const data = await readFileAsync(path);
        return JSON.parse(data.toString());
    }
    catch (err) {
        throw new Error(`Path does not exist. ${path}`);
    }
}
async function resolveBinaryPath(name, useRelative = false) {
    try {
        // This could potentially break, if the name of a binary (name) is different
        // from the name of the package.
        const packageJsonPath = await getPackageJsonPath(name, useRelative);
        const { bin: packageBin } = await loadJson(packageJsonPath);
        if (!packageBin) {
            return null;
        }
        const binaryPath = fp_1.isString(packageBin) ? packageBin : packageBin[name];
        if (!binaryPath) {
            return null;
        }
        return path_1.resolve(path_1.dirname(packageJsonPath), binaryPath);
    }
    catch (err) {
        return null;
    }
}
function getToolArguments() {
    // The standard 2 indicating node binary, executing script, and
    // the run command and the tool argument.
    const SKIP_COUNT = 4;
    const { argv } = process;
    return argv.slice(SKIP_COUNT);
}
async function executeBinary(path, args) {
    return spawn_1.spawn(path, args, {
        stdio: 'inherit',
    });
}
async function run({ argv }) {
    const { _: commandArgs } = argv;
    const [, tool] = commandArgs;
    const binPath = await resolveBinaryPath(tool);
    if (!binPath) {
        logger.error(`No executable found for ${tool}`);
        process.exit(1);
    }
    const binArgs = getToolArguments();
    try {
        await executeBinary(binPath, binArgs);
    }
    catch (err) {
        logger.error(`Executing the command "${binPath} ${binArgs.join(' ')}" failed`);
        logger.error(err);
        process.exit(1);
    }
}
exports.run = run;
